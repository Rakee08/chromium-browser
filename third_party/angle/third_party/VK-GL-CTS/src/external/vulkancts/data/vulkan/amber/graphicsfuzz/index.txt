{	"access-new-vector-inside-if-condition.amber",	"access-new-vector-inside-if-condition","A shader that accesses a new vector within an if condition"							},
{	"always-false-if-in-do-while.amber",			"always-false-if-in-do-while",			"A fragment shader with an always false if."											},
{	"always-false-if-with-discard-return.amber",	"always-false-if-with-discard-return",	"A fragment shader with discard keyword and a return"									},
{	"barrier-in-loop-with-break.amber",				"barrier-in-loop-with-break",			"A compute shader with a barrier in a loop with a break"								},
{	"break-in-do-while-with-nested-if.amber",		"break-in-do-while-with-nested-if",		"A fragment shader with nested if"														},
{	"call-if-while-switch.amber",					"call-if-while-switch",					"A fragment shader with a call, if, while, switch"										},
{	"color-write-in-loop.amber",					"color-write-in-loop",					"A fragment shader that writes to color in a loop"										},
{	"complex-nested-loops-and-call.amber",			"complex-nested-loops-and-call",		"A fragment shader with complex nested loops, breaks, etc."								},
{	"conditional-return-in-infinite-while.amber",	"conditional-return-in-infinite-while",	"A shader with conditional return inside an infinite loop"								},
{	"continue-and-merge.amber",						"continue-and-merge",					"A fragment shader with two nested loops"												},
{	"control-flow-in-function.amber",				"control-flow-in-function",				"A fragment shader with a lot of control flow"											},
{	"control-flow-switch.amber",					"control-flow-switch",					"A fragment shader with somewhat complex control flow and a switch"						},
{	"cov-const-folding-clamp.amber",				"cov-const-folding-clamp",				"A fragment shader that covers a specific const folding rule path."						},
{	"cov-const-folding-clamp-max.amber",			"cov-const-folding-clamp-max",			"A fragment shader that covers a specific const folding rule path."						},
{	"cov-const-folding-clamp-min.amber",			"cov-const-folding-clamp-min",			"A fragment shader that covers a specific const folding rule path."						},
{	"cov-const-folding-dot-condition-true.amber",	"cov-const-folding-dot-condition-true",	"A fragment shader that covers a specific const folding rule path."						},
{	"cov-const-folding-dot-determinant.amber",		"cov-const-folding-dot-determinant",	"A fragment shader that covers a specific const folding rule path."						},
{	"cov-const-folding-vector-shuffle.amber",		"cov-const-folding-vector-shuffle",		"A fragment shader that covers a specific const folding rule path."						},
{	"cov-constants-mix-uniform.amber",				"cov-constants-mix-uniform",			"A fragment shader that covers a specific constant handling path."						},
{	"cov-copy-prop-arrays-func-argument.amber",		"cov-copy-prop-arrays-func-argument",	"A fragment shader that covers a specific propagate array copy path."					},
{	"cov-copy-prop-arrays-no-stores.amber",			"cov-copy-prop-arrays-no-stores",		"A fragment shader that covers a specific propagate array copy path."					},
{	"cov-copy-prop-arrays-param-uniform.amber",		"cov-copy-prop-arrays-param-uniform",	"A fragment shader that covers a specific propagate array copy path."					},
{	"cov-dead-code-unreachable-merge.amber",		"cov-dead-code-unreachable-merge",		"A fragment shader that covers a specific dead code elimination path."					},
{	"cov-fold-bitwise-and-zero.amber",				"cov-fold-bitwise-and-zero",			"A fragment shader that covers a specific instruction folding path."					},
{	"cov-fold-bitwise-xor.amber",					"cov-fold-bitwise-xor",					"A fragment shader that covers a specific instruction folding path."					},
{	"cov-fold-div-uniform-by-zero.amber",			"cov-fold-div-uniform-by-zero",			"A fragment shader that covers a specific instruction folding path."					},
{	"cov-fold-div-variable-by-zero.amber",			"cov-fold-div-variable-by-zero",		"A fragment shader that covers a specific instruction folding path."					},
{	"cov-fold-logical-and-const-variable.amber",	"cov-fold-logical-and-const-variable",	"A fragment shader that covers a specific instruction folding path."					},
{	"cov-fold-logical-and-constant.amber",			"cov-fold-logical-and-constant",		"A fragment shader that covers a specific instruction folding path."					},
{	"cov-fold-logical-or-constant.amber",			"cov-fold-logical-or-constant",			"A fragment shader that covers a specific instruction folding path."					},
{	"cov-fold-negate-variable.amber",				"cov-fold-negate-variable",				"A fragment shader that covers a specific instruction folding path."					},
{	"cov-fold-shift-gte32.amber",					"cov-fold-shift-gte32",					"A fragment shader that covers a specific instruction folding path."					},
{	"cov-fold-shift-right-arithmetic.amber",		"cov-fold-shift-right-arithmetic",		"A fragment shader that covers a specific instruction folding path."					},
{	"cov-fold-switch-udiv.amber",					"cov-fold-switch-udiv",					"A fragment shader that covers a specific instruction folding path."					},
{	"cov-folding-rules-construct-extract.amber",	"cov-folding-rules-construct-extract",	"A fragment shader that covers a specific instruction folding path."					},
{	"cov-folding-rules-merge-add-sub.amber",		"cov-folding-rules-merge-add-sub",		"A fragment shader that covers a specific instruction folding path."					},
{	"cov-folding-rules-merge-sub-add.amber",		"cov-folding-rules-merge-sub-add",		"A fragment shader that covers a specific instruction folding path."					},
{	"cov-folding-rules-merge-sub-sub.amber",		"cov-folding-rules-merge-sub-sub",		"A fragment shader that covers a specific instruction folding path."					},
{	"dead-barriers-in-loops.amber",					"dead-barriers-in-loops",				"A compute shader with dead barriers"													},
{	"dead-struct-init.amber",						"dead-struct-init",						"A fragment shader that uses struct initializers"										},
{	"disc-and-add-in-func-in-loop.amber",			"disc-and-add-in-func-in-loop",			"A fragment shader with discard and add in function in loop"							},
{	"discard-continue-return.amber",				"discard-continue-return",				"A fragment shader with a discard, continue, and return"								},
{	"discard-in-array-manipulating-loop.amber",		"discard-in-array-manipulating-loop",	"An array-manipulating fragment shader with a discard"									},
{	"discard-in-loop.amber",						"discard-in-loop",						"A shader with a discard in a loop"														},
{	"discard-in-loop-in-function.amber",			"discard-in-loop-in-function",			"A shader with a discard nested in a loop in a function"								},
{	"discards-in-control-flow.amber",				"discards-in-control-flow",				"A fragment shader with discards in loops and conditionals"								},
{	"do-while-loop-in-conditionals.amber",			"do-while-loop-in-conditionals",		"A fragment shader with do-while loop in conditional nest"								},
{	"do-while-with-always-true-if.amber",			"do-while-with-always-true-if",			"A fragment shader with a do while that always returns"									},
{	"early-return-and-barrier.amber",				"early-return-and-barrier",				"A compute shader with an early return and a barrier"									},
{	"for-condition-always-false.amber",				"for-condition-always-false",			"A fragment shader that uses a for loop with condition always false"					},
{	"for-loop-with-return.amber",					"for-loop-with-return",					"A fragment shader with a for loop that loops only once"								},
{	"for-with-ifs-and-return.amber",				"for-with-ifs-and-return",				"A fragment shader with two ifs and return/continue inside a for loop"					},
{	"fragcoord-control-flow.amber",					"fragcoord-control-flow",				"A fragment shader that uses FragCoord and somewhat complex control flow"				},
{	"fragcoord-control-flow-2.amber",				"fragcoord-control-flow-2",				"A fragment shader that uses FragCoord and somewhat complex control flow"				},
{	"global-array-loops.amber",						"global-array-loops",					"A loop that writes then reads a global array"											},
{	"if-and-switch.amber",							"if-and-switch",						"A fragment shader with a switch and some data flow"									},
{	"injection-switch-as-comparison.amber",			"injection-switch-as-comparison",		"A fragment shader with uniform comparison in loop"										},
{	"int-mat2-struct.amber",						"int-mat2-struct",						"Fragment shader using (int, mat2) struct"												},
{	"loop-call-discard.amber",						"loop-call-discard",					"A fragment shader with nested loops and a function call"								},
{	"loop-dead-if-loop.amber",						"loop-dead-if-loop",					"A fragment shader with a loop, dead if, and a loop"									},
{	"loop-nested-ifs.amber",						"loop-nested-ifs",						"A fragment shader with a for loop containing nested ifs"								},
{	"loops-breaks-returns.amber",					"loops-breaks-returns",					"A compute shader with loops, breaks, returns"											},
{	"loops-ifs-continues-call.amber",				"loops-ifs-continues-call",				"A fragment shader with nested control flow and a call"									},
{	"mat-array-deep-control-flow.amber",			"mat-array-deep-control-flow",			"A fragment shader that uses an array of matrices and has deep control flow"			},
{	"mat-array-distance.amber",						"mat-array-distance",					"A fragment shader that uses an array of matrices and distance"							},
{	"mat-mul-in-loop.amber",						"mat-mul-in-loop",						"Shader with matrix multiplication in loop"												},
{	"matrices-and-return-in-loop.amber",			"matrices-and-return-in-loop",			"A fragment shader with matrices and a return in a loop"								},
{	"max-mix-conditional-discard.amber",			"max-mix-conditional-discard",			"A fragment shader with an expression used in two discard guards"						},
{	"mix-floor-add.amber",							"mix-floor-add",						"A fragment shader with mix, uintBitsToFloat, and floor"								},
{	"modf-gl-color.amber",							"modf-gl-color",						"A fragment shader with modf of gl color"												},
{	"modf-temp-modf-color.amber",					"modf-temp-modf-color",					"A fragment shader that calls modf twice, once with color"								},
{	"nested-for-break-mat-color.amber",				"nested-for-break-mat-color",			"Two nested for loops modify a mat4 then writes red"									},
{	"nested-for-loops-with-return.amber",			"nested-for-loops-with-return",			"A fragment shader with two nested for loops with return"								},
{	"nested-ifs-and-return-in-for-loop.amber",		"nested-ifs-and-return-in-for-loop",	"A fragment shader with return in nest of ifs, inside loop"								},
{	"nested-loops-switch.amber",					"nested-loops-switch",					"A fragment shader with nested loops and a switch"										},
{	"pow-vec4.amber",								"pow-vec4",								"A fragment shader that uses pow"														},
{	"return-before-writing-wrong-color.amber",		"return-before-writing-wrong-color",	"A fragment shader with return before writing wrong color"								},
{	"return-float-from-while-loop.amber",			"return-float-from-while-loop",			"A fragment shader with unreachable while loop"											},
{	"return-in-loop-in-function.amber",				"return-in-loop-in-function",			"A fragment shader with early return from loop in function"								},
{	"return-inside-loop-in-function.amber",			"return-inside-loop-in-function",		"A fragment shader with return inside loop"												},
{	"returned-boolean-in-vector.amber",				"returned-boolean-in-vector",			"A fragment shader with returned boolean in vector"										},
{	"similar-nested-ifs.amber",						"similar-nested-ifs",					"A fragment shader with similar nested ifs and loops"									},
{	"smoothstep-after-loop.amber",					"smoothstep-after-loop",				"Fragment shader with 1-iteration loop and smoothstep"									},
{	"struct-and-unreachable-infinite-loop.amber",	"struct-and-unreachable-infinite-loop",	"Fragment shader with struct and unreachable infinite loop"								},
{	"struct-controlled-loop.amber",					"struct-controlled-loop",				"Shader with loop controlled by struct"													},
{	"struct-used-as-temporary.amber",				"struct-used-as-temporary",				"A fragment shader that uses a temporary struct variable"								},
{	"switch-case-with-undefined-expression.amber",	"switch-case-with-undefined-expression","A fragment shader with undefined expression"											},
{	"switch-if-discard.amber",						"switch-if-discard",					"A fragment shader with a switch, if, and discard"										},
{	"switch-with-empty-if-false.amber",				"switch-with-empty-if-false",			"A fragment shader with always false if in switch statement"							},
{	"swizzle-struct-init-min.amber",				"swizzle-struct-init-min",				"A fragment shader that uses vector swizzles, struct initializers, and min"				},
{	"transpose-rectangular-matrix.amber",			"transpose-rectangular-matrix",			"Fragment shader that uses 'transpose'"													},
{	"two-2-iteration-loops.amber",					"two-2-iteration-loops",				"Fragment shader with pair of outer loops"												},
{	"two-for-loops-with-barrier-function.amber",	"two-for-loops-with-barrier-function",	"A compute shader with two barrier functions"											},
{	"two-loops-matrix.amber",						"two-loops-matrix",						"A fragment shader with two loops and some matrices"									},
{	"two-loops-set-struct.amber",					"two-loops-set-struct",					"A fragment shader with two loops that write to a struct"								},
{	"two-loops-with-break.amber",					"two-loops-with-break",					"A fragment shader with two loops with breaks"											},
{	"two-nested-do-whiles.amber",					"two-nested-do-whiles",					"A fragment shader with nested do while"												},
{	"two-nested-for-loops-with-returns.amber",		"two-nested-for-loops-with-returns",	"A compute shader with two nested for loops"											},
{	"two-nested-infinite-loops-discard.amber",		"two-nested-infinite-loops-discard",	"A fragment shader with an always false if function"									},
{	"undefined-integer-in-function.amber",			"undefined-integer-in-function",		"A fragment shader with nested do while and undefined int"								},
{	"uninit-element-cast-in-loop.amber",			"uninit-element-cast-in-loop",			"A fragment shader with uninitialized element cast in loop"								},
{	"uninitialized-var-decrement-and-add.amber",	"uninitialized-var-decrement-and-add",	"A fragment shader that uses an uninitialized variable"									},
{	"undefined-assign-in-infinite-loop.amber",		"undefined-assign-in-infinite-loop",	"A fragment shader with uninitialized read in infinite loop"							},
{	"unreachable-barrier-in-loops.amber",			"unreachable-barrier-in-loops",			"A compute shader with an unreachable barrier in a loop nest"							},
{	"unreachable-continue-statement.amber",			"unreachable-continue-statement",		"A fragment shader with unreachable continue statement"									},
{	"unreachable-discard-statement-in-if.amber",	"unreachable-discard-statement-in-if",	"A fragment shader with discard keyword and a return"									},
{	"unreachable-discard-statement.amber",			"unreachable-discard-statement",		"A fragment shader with unreachable discard statement"									},
{	"unreachable-loops.amber",						"unreachable-loops",					"Fragment shader that writes red despite unreachable loops"								},
{	"unreachable-loops-in-switch.amber",			"unreachable-loops-in-switch",			"A fragment shader with unreachable loops in a switch"									},
{	"unreachable-return-in-loop.amber",				"unreachable-return-in-loop",			"A fragment shader with an unreachable return in a loop"								},
{	"unreachable-switch-case-with-discards.amber",	"unreachable-switch-case-with-discards","A shader with a switch statement containing unreachable discards"						},
{	"uv-value-comparison-as-boolean.amber",			"uv-value-comparison-as-boolean",		"A fragment shader with uv value comparison as boolean"									},
{	"while-function-always-false.amber",			"while-function-always-false",			"A fragment shader with an always false while function"									},
{	"while-inside-switch.amber",					"while-inside-switch",					"A fragment shader that uses a while loop inside a switch"								},
{	"write-before-break.amber",						"write-before-break",					"Fragment shader that writes red before loop break"										},
{	"write-red-in-loop-nest.amber",					"write-red-in-loop-nest",				"A fragment shader that writes red in a nest of loops"									},
{	"wrong-color-in-always-false-if.amber",			"wrong-color-in-always-false-if",		"A fragment shader with wrong color write in false if"									},
